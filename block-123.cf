: ->code code + ;
: ->vars vars + ;
: ->dict dict + ;
: here  (here)  @c ;
: last  (last)  @c ;
: vhere (vhere) @c ;
: lex   (lex)   @c ;
: >lex  (lex)   !c ;
: , here dup 1+ (here) !c !c ;
: begin here ;
: again (jmp)   , , ;
: while (jmpnz) , , ;
: until (jmpz)  , , ;
: if (jmpz) , here 0 , ;
: else (jmp) , here swap 0 , here swap !c ;
: then here swap !c ;
: ( [ begin ]
    >in @ c@ 
    dup  0= [ if ] drop exit [ then ]
    >in @ 1+ >in !
    ')' = [ if ] exit [ then ]
  [ again ] ;
: allot vhere + (vhere) !c ;
: ,v  vhere ->vars ! cell allot ;
: hex     $10 base !c ;
: binary  %10 base !c ;
: decimal #10 base !c ;
: cells cell * ;
: nip swap drop ;
: tuck swap over ;
: ?dup dup [ if ] dup [ then ] ;
: 2dup over over ;
: min ( a b--c ) 2dup > [ if ] swap [ then ] drop ;
: max ( a b--c ) 2dup < [ if ] swap [ then ] drop ;
: 2+ 1+ 1+ ;
: negate com 1+ ;
: abs dup 0 < [ if ] negate [ then ] ;
: mod /mod drop ;
: +! tuck @ + swap ! ;
: space 32 emit ;
: (.) to-string count type ;
: . (.) space ;
: cr 13 emit 10 emit ;
: tab 9 emit ;
: ?  @ . ;
: ->xt     w@ ;
: ->size   2 + c@ ;
: ->flags  3 + c@ ;
: ->lex    4 + c@ ;
: ->len    5 + ;
: ->name   6 + ;
: lex-match? ( a--f )  ->lex lex =  lex 0=  or ;
: words a >r  0 dup >a >r  last ->dict [ begin ]
      dup lex-match? [ if ]
        dup ->len count type  r> 1+ >r
        dup ->len c@ 7 > [ if ] a+ drop [ then ]
        a+ 8 > [ if ] cr 0 >a [ else ] tab [ then ]
      [ then ]
      dup ->size + dup dict-sz ->dict <
    [ while ] drop '(' emit r> . [ ." words)" ] r> >a ;
: ,1 dup $ffff and , $10000 / ;
: ,cell cell 2 / for ,1 next drop ;
: var (lit2) , vhere ->vars ,cell cell allot (exit) , ;
: hh 10 ; : ll 11 ; : vv 12 ;
: marker here hh !C last ll !C vhere vv !C ;
: forget hh @c (here) !c ll @c (last) !c vv @c (vhere) !c 0 >lex ;
marker
: .02 '.' emit dup 10 < [ if ] 0 (.) [ then ] (.) ;
: .ver version 100 /mod 100 /mod (.) .02 .02 ;
: hi [ ." c4 - v" ] .ver [ ."  - Chris Curl." ] cr ;
[ hi
[ forget
( 6 load )
( 3 load )
( 5 load )
[ 0 >lex
